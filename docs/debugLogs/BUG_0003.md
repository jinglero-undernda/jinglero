# BUG_0003 – Admin page fetching wrong entity type on navigation

## Metadata

- **Status**: `resolved`
- **Last Updated**: 2025-11-17
- **Category**: `frontend`
- **Severity**: `high`
- **Environment**: Browser (Chrome/Safari), localhost:5173
- **Related Commits / PRs**: TBD (BUG_0003: Fix race condition in AdminEntityAnalyze entity loading)

## Reproduction Steps

1. Navigate to a Tematica admin page: `http://localhost:5173/admin/t/TEM-007`
2. From that page, click on a Jingle to navigate to its admin page: `http://localhost:5173/admin/j/JIN-ec3ce303-a65c-487d-98a6-8474d68d502c`
3. Observe console error:
   ```
   GET http://localhost:5173/api/public/jingles/TEM-007 404 (Not Found)
   relationshipService.ts:137 [fetchJingleAllRelationships] Error fetching jingle TEM-007: Error: Jingle not found
   ```

**Expected behavior**: The app should fetch the Jingle with ID `JIN-ec3ce303...` using the correct endpoint `/api/public/jingles/JIN-ec3ce303...`

**Actual behavior**: The app attempts to fetch a Jingle using the previous entity's ID (`TEM-007`), resulting in a 404 error.

## Description

When navigating between different entities in the admin interface, the `RelatedEntities` component briefly uses stale entity data from the previous page. This causes it to attempt fetching relationships for the wrong entity ID with the new entity type.

For example, navigating from Tematica `TEM-007` to Jingle `JIN-ec3ce303...` results in the app trying to fetch `/api/public/jingles/TEM-007` (a Jingle with a Tematica ID), which doesn't exist.

**Console Output**:

```
client.ts:102  GET http://localhost:5173/api/public/jingles/TEM-007 404 (Not Found)
get @ client.ts:102
getJingle @ client.ts:182
(anonymous) @ relationshipService.ts:125
fetchJingleAllRelationships @ relationshipService.ts:146
fetchJingleFabrica @ relationshipService.ts:205
fetchFn @ relationshipConfigs.ts:47
(anonymous) @ RelatedEntities.tsx:1349
```

## Root Cause

The issue stems from a **race condition in state management** in the `AdminEntityAnalyze` component:

1. When the user navigates to a new entity page (e.g., from `/admin/t/TEM-007` to `/admin/j/JIN-ec3ce303...`), the component's `useEffect` triggers
2. The `useEffect` sets `loading = true` and starts fetching the new entity
3. **However**, the old `entity` state (containing `TEM-007`) is **not cleared immediately**
4. The component continues to render with the old entity while `loading` is still `false` initially
5. The `RelatedEntities` component receives:
   - `entity.id = "TEM-007"` (old, stale data)
   - `entityType = "jingle"` (new, correct data)
6. `RelatedEntities` immediately starts loading relationships using the mismatched data
7. This triggers `fetchJingleFabrica("TEM-007")` which tries to fetch `/api/public/jingles/TEM-007` → 404 error

**The core issue**: The entity state was not being reset to `null` when starting to load a new entity, creating a window where stale entity data could be used with the new entity type.

## Resolution

**Fixes Applied**:

### Fix 1: Clear stale entity state in AdminEntityAnalyze

Add `setEntity(null)` at the start of the `fetchEntity` function to immediately clear stale entity state:

```typescript
const fetchEntity = async () => {
  try {
    // CRITICAL: Clear the entity state immediately when starting to load a new entity
    // This prevents RelatedEntities from using stale entity data with mismatched entityType
    setEntity(null);
    setLoading(true);
    setError(null);
    // ... rest of fetch logic
```

**Why this helps**: By setting `entity = null` immediately, the component's rendering logic hits the safety check `if (error || !entity)`, preventing `RelatedEntities` from being rendered with mismatched entity/entityType data.

### Fix 2: Add entity ID/type validation guard in RelatedEntities

Added validation in the `RelatedEntities` useEffect to detect and skip loading when entity ID doesn't match entity type:

```typescript
useEffect(() => {
  if (entityPath.length <= 1 && entity?.id) {
    // CRITICAL: Validate that entity.id matches entityType to prevent race conditions
    const detectedType = entity.id.startsWith('JIN-') ? 'jingle'
      : entity.id.startsWith('CAN-') ? 'cancion'
      : entity.id.startsWith('ART-') ? 'artista'
      : entity.id.startsWith('TEM-') ? 'tematica'
      : 'fabrica';

    if (detectedType !== entityType) {
      console.warn('[RelatedEntities] Entity ID/Type mismatch detected, skipping load');
      return; // Skip loading until entity and entityType are synchronized
    }
    // ... continue loading relationships
```

**Why this works**: Even if React's async state updates allow the old entity to persist briefly with the new entityType, this guard prevents any API calls from being made with mismatched data.

### Fix 3: Update Fabrica schema to include legacy "TBC" status

The database contained Fabrica entities with `status: "TBC"` (To Be Confirmed), but the validation schema only accepted `"DRAFT" | "PROCESSING" | "COMPLETED"`. Updated:

- `/frontend/src/lib/validation/relationshipSchemas.ts`: Added `'TBC'` to FabricaSchema status enum
- `/frontend/src/types/index.ts`: Added `'TBC'` to Fabrica TypeScript interface

**Why this was needed**: Legacy data in the database uses "TBC" status, causing validation errors. The frontend schema needs to be lenient to handle legacy data gracefully.

**Validation**:

- Manual testing: Navigate between different entity types in admin interface (TEM-007 → JIN-0004, TEM-007 → JIN-ec3ce303, etc.)
- No linter errors introduced
- Existing safety checks properly handle the null state
- Schema validation no longer fails for Fabrica with "TBC" status

**Follow-up items**:

- Consider adding similar protection in other pages that fetch entities (e.g., inspect pages)
- Monitor for similar race conditions in other state management scenarios
- Consider data migration script to update legacy "TBC" status values to current schema values

## Related Files

- `/Users/william/Usina/jinglero/frontend/src/pages/admin/AdminEntityAnalyze.tsx`

  - Search for: `const fetchEntity = async () => {`
  - Line ~103-110: **Fix 1** - Added `setEntity(null)` before fetching
  - Line ~68-166: Main `useEffect` that loads entities
  - Line ~318-362: Safety check `if (error || !entity)` that prevents rendering with null entity

- `/Users/william/Usina/jinglero/frontend/src/components/common/RelatedEntities.tsx`

  - Search for: `// CRITICAL: Validate that entity.id matches entityType`
  - Line ~1276-1292: **Fix 2** - Added entity ID/type validation guard in useEffect
  - Line ~1349: Where `rel.fetchFn(entity.id, entityType)` is called
  - Line ~1274-1434: useEffect that auto-loads relationships on mount

- `/Users/william/Usina/jinglero/frontend/src/lib/validation/relationshipSchemas.ts`

  - Search for: `FabricaSchema`
  - Line ~78-79: **Fix 3** - Added `'TBC'` to Fabrica status enum
  - Updated status from `z.enum(['DRAFT', 'PROCESSING', 'COMPLETED'])` to include `'TBC'`

- `/Users/william/Usina/jinglero/frontend/src/types/index.ts`

  - Search for: `interface Fabrica`
  - Line ~60: **Fix 3** - Added `'TBC'` to Fabrica TypeScript type
  - Updated status from `'DRAFT' | 'PROCESSING' | 'COMPLETED'` to include `| 'TBC'`

- `/Users/william/Usina/jinglero/frontend/src/lib/services/relationshipService.ts`

  - Search for: `async function fetchJingleAllRelationships`
  - Line ~111-151: Function that was being called with wrong ID
  - Line ~125: `await publicApi.getJingle(jingleId)` - where 404 originated

- `/Users/william/Usina/jinglero/frontend/src/lib/api/client.ts`

  - Search for: `async getJingle(id: string)`
  - Line ~181-183: Public API method that makes the GET request
  - Line ~101-117: Error handling that throws "Jingle not found"

- `/Users/william/Usina/jinglero/frontend/src/lib/utils/relationshipConfigs.ts`
  - Search for: `fetchFn: (entityId: string`
  - Line ~40-81: Jingle relationship configurations
  - Line ~47: `fetchFn` for Fabrica relationship that triggered the error

## Related Code

### Fix 1: Clear stale entity state

**Before (buggy code)**:

```typescript
const fetchEntity = async () => {
  try {
    setLoading(true);
    setError(null);
    // entity state still contains old entity (TEM-007) at this point
    // RelatedEntities renders with stale data before we finish fetching
```

**After (fixed code)**:

```typescript
const fetchEntity = async () => {
  try {
    // CRITICAL: Clear the entity state immediately when starting to load a new entity
    // This prevents RelatedEntities from using stale entity data with mismatched entityType
    setEntity(null);
    setLoading(true);
    setError(null);
```

### Fix 2: Entity ID/Type validation guard

**Added to RelatedEntities useEffect**:

```typescript
useEffect(() => {
  if (entityPath.length <= 1 && entity?.id) {
    // CRITICAL: Validate that entity.id matches entityType to prevent race conditions
    const detectedType = entity.id.startsWith('JIN-') ? 'jingle'
      : entity.id.startsWith('CAN-') ? 'cancion'
      : entity.id.startsWith('ART-') ? 'artista'
      : entity.id.startsWith('TEM-') ? 'tematica'
      : 'fabrica';

    if (detectedType !== entityType) {
      console.warn('[RelatedEntities] Entity ID/Type mismatch detected, skipping load');
      return; // Early return prevents loading with mismatched data
    }

    // ... continue loading relationships
  }
}, [entity?.id, entityType, ...]);
```

### Fix 3: Schema update for legacy status

**Before**:

```typescript
// relationshipSchemas.ts
status: z.enum(["DRAFT", "PROCESSING", "COMPLETED"]).optional();

// types/index.ts
status: "DRAFT" | "PROCESSING" | "COMPLETED";
```

**After**:

```typescript
// relationshipSchemas.ts
status: z.enum(["DRAFT", "PROCESSING", "COMPLETED", "TBC"]).optional();

// types/index.ts
status: "DRAFT" | "PROCESSING" | "COMPLETED" | "TBC"; // TBC is legacy status value
```
