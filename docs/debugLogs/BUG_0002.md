# BUG_0002 â€“ Admin relationships toggle marks dirty state

## Metadata

- **Status**: open
- **Last Updated**: 2025-11-17
- **Category**: frontend (admin dashboard)
- **Severity**: medium
- **Environment**: Admin dashboard in browser (macOS 12.6 / Chrome latest, per reporter)
- **Related Commits / PRs**: _TBD_

## Reproduction Steps

1. Open any jingle detail page in the Admin dashboard (`/admin/j/<jingleId>`).
2. Click the `Editar` button in the heading card to enter edit mode (Guardar remains disabled as expected).
3. Expand any relationship row (e.g., `ðŸ­ ESPECIAL DIEGO MARADONA â€¦`) to reveal its nested properties.
4. Observe that the status pill switches to â€œChangedâ€ and the `Guardar` button becomes enabled even though no field was modified.

**Expected**: Expanding a relationship to view its properties should not count as an edit until a property value actually changes.

**Actual**: Merely expanding the relationship marks the entity as dirty and enables the save button.

## Description

In Admin edit mode, relationship rows expose editable property forms. Simply expanding one of these forms triggers the global `hasUnsavedChanges` signal, making the UI think there are pending edits. This causes noisy â€œChangedâ€ indicators and risks spurious saves/cancel dialogs even when nothing was edited.

## Root Cause

`RelatedEntities` used a naive `hasUnsavedChanges` heuristic: any populated entry inside `relationshipPropsData` or `timestampTimes` was treated as a pending edit. Expanding a relationship loads its properties and stores them in those maps so the inputs can be controlled, which immediately tripped the dirty-state check even though the values still matched the backend.

## Resolution

- Added `relationshipPropsInitialData` to capture the original snapshot for each expanded relationship.
- Reworked `hasUnsavedChanges` to diff the current props against the stored baseline (and only consider blank-row selections as implicit changes).
- Scoped `getRelationshipProperties()` to return only the relationships whose values diverged from the baseline, preventing redundant saves.
- Clearing unsaved changes now supports a commit-aware flow so successful saves promote the latest values to the baseline while cancellations revert to the previously fetched snapshot, keeping the UI in sync without forcing a manual re-expand.

## Related Files

- `frontend/src/components/common/RelatedEntities.tsx`: search for `hasUnsavedChanges` and `relationshipPropsData` â€“ logic that signals edits upon expansion.
- `frontend/src/pages/admin/AdminEntityAnalyze.tsx`: search for `setRelationshipHasChanges` â€“ page-level handler that toggles the Guardar button based on `onChange`.

## Related Code

`frontend/src/components/common/RelatedEntities.tsx`

```1147:1205:frontend/src/components/common/RelatedEntities.tsx
const isRelationshipPropsDirty = useCallback((key: string) => {
  const currentProps = relationshipPropsData[key];
  if (!currentProps) {
    return false;
  }
  const initialProps = relationshipPropsInitialData[key];
  if (!initialProps) {
    return Object.values(currentProps).some(
      (value) => value !== null && value !== undefined && value !== ''
    );
  }
  return !arePropsEqual(initialProps, currentProps);
}, [relationshipPropsData, relationshipPropsInitialData, arePropsEqual]);

const hasUnsavedChanges = useCallback(() => {
  const hasDirtyRelationshipProps = Object.keys(relationshipPropsData).some(isRelationshipPropsDirty);
  if (hasDirtyRelationshipProps) {
    return true;
  }
  if (selectedEntityForRelationship !== null) {
    return true;
  }
  return false;
}, [relationshipPropsData, selectedEntityForRelationship, isRelationshipPropsDirty]);

useEffect(() => {
  if (onChange && isEditing) {
    onChange(hasUnsavedChanges());
  } else if (onChange && !isEditing) {
    onChange(false);
  }
}, [relationshipPropsData, selectedEntityForRelationship, hasUnsavedChanges, onChange, isEditing]);
```

`frontend/src/pages/admin/AdminEntityAnalyze.tsx`

```640:642:frontend/src/pages/admin/AdminEntityAnalyze.tsx
        <RelatedEntities
          ...
          onChange={(hasChanges) => {
            setRelationshipHasChanges(hasChanges);
          }}
```
